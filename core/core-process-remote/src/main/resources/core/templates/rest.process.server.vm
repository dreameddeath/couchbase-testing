/*
 * Copyright Christophe Jeunesse
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package ${service.packageName};

import javax.annotation.Generated;

import com.dreameddeath.core.service.annotation.ServiceDef;
import com.dreameddeath.couchbase.core.process.remote.service.AbstractRemoteJobRestService;
import com.dreameddeath.couchbase.core.process.remote.model.rest.RemoteJobResultWrapper;

import java.util.stream.Collectors;
import java.util.AbstractMap.SimpleImmutableEntry;
import java.util.Map;

#foreach($importName in $service.job.getServiceImports())
import ${importName};
#end

import javax.ws.rs.Path;

@Generated(
    value = "${generator.name}",
    date = "${generator.date}",
    comments = "${generator.comment}"
)

@ServiceDef(domain = "${service.domain}",name="${service.name}",version = "${service.version}")
@Path("${service.path}")
public class ${service.className} extends AbstractRemoteJobRestService<${service.job.shortName},${service.request.shortName},${service.response.shortName}> {
    @Override
    protected ${service.job.shortName} buildJobFromRequest(${service.request.shortName} request) {
        return ${service.request.mapFctName}(request);
    }


    @Override
    protected ${service.response.shortName} buildResponse(${service.job.shortName} job) {
        return ${service.response.mapFctName}(job);
    }

    public static class WrappedResponse extends RemoteJobResultWrapper<${service.response.shortName}> {
        public WrappedResponse(${service.response.shortName} result) {
            super(result);
        }
    }

    @Override
    protected final Class<WrappedResponse> getResponseClass(){
        return WrappedResponse.class;
    }

#foreach($model in $service.models.values())
#if($model.isRequest())
    private $model.origClassSimpleName ${model.mapFctName}(#if($model.isUnwrapped())${model.getUnwrappedSourceShortName()} #else ${model.shortName} #end source){
        if(source==null) return null;
#if($model.hasChildClasses())
        ${model.origClassSimpleName} result;
#foreach($subModel in $model.getFirstLevelChilds())
        if(source instanceof ${subModel.shortName}){
            result = ${model.mapFctName}((${subModel.shortName})source);
        } #if($foreach.hasNext) else #end
#end
        else {
            throw new RuntimeException("Unmanage class mapping " + source.getClass().getName());
        }
#else
        ${model.origClassSimpleName} result = new ${model.origClassSimpleName}();
#end
#foreach($field in ${model.fieldsForMapping})
        ${service.job.buildSetter("result",$model,$field,$service.job.buildGetterWithMapping("source",$model,$field))};
#end
        return result;
    }
#else
    private #if($model.isUnwrapped())${model.getUnwrappedSourceShortName()} #else ${model.shortName} #end ${model.mapFctName}(#if($model.isUnwrapped())${model.getUnwrappedSourceShortName()} result,#end ${model.origClassSimpleName} source){
        if(source==null) return null;
#if(!$model.isUnwrapped())
#if($model.hasChildClasses())
        ${model.shortName} result;
#foreach($subModel in $model.getFirstLevelChilds())
        if(source instanceof ${subModel.origClassSimpleName}){
            result = ${model.mapFctName}((${subModel.origClassSimpleName})source);
        } #if($foreach.hasNext) else #end
#end
        else {
            throw new RuntimeException("Unmanage class mapping " + source.getClass().getName());
        }
#else
        ${model.shortName} result = new ${model.shortName}();
#end
#end
#foreach($field in ${model.fieldsForMapping})
        ${service.job.buildSetter("result",$model,$field,$service.job.buildGetterWithMapping("source",$model,$field))};
#end
        return result;
    }
#end

#end

#foreach($enum in $service.enums.values())
#if($enum.isForRequest())
    private ${enum.origClassSimpleName} mapEnum(${enum.shortName} source){
        String sourceValue = (source==null)?null:source.toString();
        for(${enum.origClassSimpleName} value:${enum.origClassSimpleName}.values()){
            if(value.toString().equals(sourceValue)){
                return value;
            }
        }
        return null;
    }
#end

#if($enum.isForResponse())
    private ${enum.getShortName()} mapEnum(${enum.origClassSimpleName} source){
        String sourceValue = (source==null)?null:source.toString();
        for(${enum.getShortName()} value:${enum.getShortName()}.values()){
            if(value.toString().equals(sourceValue)){
                return value;
            }
        }
        return null;
    }
#end
#end
}