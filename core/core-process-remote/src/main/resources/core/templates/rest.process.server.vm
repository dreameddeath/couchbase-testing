/*
 * Copyright Christophe Jeunesse
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package ${service.packageName};

import javax.annotation.Generated;

import com.dreameddeath.core.service.annotation.ServiceDef;
import com.dreameddeath.core.service.annotation.DataAccessType;
import com.dreameddeath.core.user.IUser;
import com.dreameddeath.couchbase.core.process.remote.model.rest.ActionRequest;
import com.dreameddeath.couchbase.core.process.remote.service.AbstractRemoteJobRestService;
import com.dreameddeath.couchbase.core.process.remote.model.rest.RemoteJobResultWrapper;


import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import io.swagger.annotations.ApiParam;
import io.swagger.annotations.ApiResponses;
import io.swagger.annotations.ApiResponse;

import java.util.stream.Collectors;
import java.util.AbstractMap.SimpleImmutableEntry;
import java.util.Map;

#foreach($importName in $service.job.getServiceImports())
import ${importName};
#end

import javax.ws.rs.POST;
import javax.ws.rs.GET;
import javax.ws.rs.PUT;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.QueryParam;
import javax.ws.rs.PathParam;
import javax.ws.rs.container.AsyncResponse;
import javax.ws.rs.container.Suspended;
import javax.ws.rs.core.Context;
import javax.ws.rs.core.MediaType;

import static com.dreameddeath.couchbase.core.process.remote.service.AbstractRemoteJobRestService.REQUEST_UID_QUERY_PARAM;
import static com.dreameddeath.couchbase.core.process.remote.service.AbstractRemoteJobRestService.SUBMIT_ONLY_QUERY_PARAM;


@Generated(
    value = "${generator.name}",
    date = "${generator.date}",
    comments = "${generator.comment}"
)

@ServiceDef(domain = "${service.domain}",type=AbstractRemoteJobRestService.SERVICE_TYPE,name="${service.name}",version = "${service.version}",access=DataAccessType.READ_WRITE)
@Path("${service.path}")
@Api(value = "${service.path}", description = "${service.descr}")
public class ${service.className} extends AbstractRemoteJobRestService<${service.job.shortName},${service.request.shortName},${service.response.shortName}> {
    @Override
    protected ${service.job.shortName} buildJobFromRequest(${service.request.shortName} request) {
        return ${service.request.mapFctName}(request);
    }


    @Override
    protected ${service.response.shortName} buildResponse(${service.job.shortName} job) {
        return ${service.response.mapFctName}(job);
    }

    public static class WrappedResponse${service.response.shortName} extends RemoteJobResultWrapper<${service.response.shortName}> {
        public WrappedResponse${service.response.shortName}(${service.response.shortName} result) {
            super(result);
        }
    }


    @POST
    @Produces(MediaType.APPLICATION_JSON)
    @ApiResponses(value = {
          @ApiResponse(code = 200, message= "The processing result",response = WrappedResponse${service.response.shortName}.class),
          @ApiResponse(code = 409, message = "Conflict with request uid")
    })
    public void runJobCreate(@Context IUser user,
                                 @QueryParam(SUBMIT_ONLY_QUERY_PARAM) Boolean submitOnly,
                                 @QueryParam(REQUEST_UID_QUERY_PARAM) String requestUid,
                                 ${service.request.shortName} request,
                                 @Suspended final AsyncResponse asyncResponse){
        super.doRunJobCreate(user,submitOnly,requestUid,request,asyncResponse);
    }

    @GET
    @Path("/{uid}")
    @Produces(MediaType.APPLICATION_JSON)
    @ApiResponses(value = {
              @ApiResponse(code = 200, message= "The processing result",response = WrappedResponse${service.response.shortName}.class),
              @ApiResponse(code = 404, message = "Job not found")
    })
    public void getJob(@Context IUser user,
                       @PathParam("uid") String uid,
                       @Suspended AsyncResponse asyncResponse) {
       super.doGetJob(user,uid,asyncResponse);
    }

    @PUT
    @Path("/{uid}/{action:cancel|resume}")
    @Produces(MediaType.APPLICATION_JSON)
    @ApiResponses(value = {
              @ApiResponse(code = 200, message= "The processing result",response = WrappedResponse${service.response.shortName}.class),
              @ApiResponse(code = 404, message = "Job not found")
    })
    public void updateJob(  @Context final IUser user,
                            @PathParam("uid") final String uid,
                            @QueryParam(REQUEST_UID_QUERY_PARAM) final String requestUid,
                            @PathParam("action") final ActionRequest actionRequest,
                            @Suspended final AsyncResponse asyncResponse)
    {
        super.doUpdateJob(user,uid,requestUid,actionRequest,asyncResponse);
    }


    @Override
    protected final Class<WrappedResponse${service.response.shortName}> getResponseClass(){
        return WrappedResponse${service.response.shortName}.class;
    }

#foreach($model in $service.models.values())
#if($model.isRequest())
    private $model.origClassSimpleName ${model.mapFctName}(#if($model.isUnwrapped())${model.getUnwrappedSourceShortName()} #else ${model.shortName} #end source){
        if(source==null) return null;
#if($model.hasChildClasses())
        ${model.origClassSimpleName} result;
#foreach($subModel in $model.getFirstLevelChilds())
        if(source instanceof ${subModel.shortName}){
            result = ${model.mapFctName}((${subModel.shortName})source);
        } #if($foreach.hasNext) else #end
#end
        else {
            throw new RuntimeException("Unmanage class mapping " + source.getClass().getName());
        }
#else
        ${model.origClassSimpleName} result = new ${model.origClassSimpleName}();
#end
#foreach($field in ${model.fieldsForMapping})
        ${service.job.buildSetter("result",$model,$field,$service.job.buildGetterWithMapping("source",$model,$field))};
#end
        return result;
    }
#else
    private #if($model.isUnwrapped())${model.getUnwrappedSourceShortName()} #else ${model.shortName} #end ${model.mapFctName}(#if($model.isUnwrapped())${model.getUnwrappedSourceShortName()} result,#end ${model.origClassSimpleName} source){
        if(source==null) return null;
#if(!$model.isUnwrapped())
#if($model.hasChildClasses())
        ${model.shortName} result;
#foreach($subModel in $model.getFirstLevelChilds())
        if(source instanceof ${subModel.origClassSimpleName}){
            result = ${model.mapFctName}((${subModel.origClassSimpleName})source);
        } #if($foreach.hasNext) else #end
#end
        else {
            throw new RuntimeException("Unmanage class mapping " + source.getClass().getName());
        }
#else
        ${model.shortName} result = new ${model.shortName}();
#end
#end
#foreach($field in ${model.fieldsForMapping})
        ${service.job.buildSetter("result",$model,$field,$service.job.buildGetterWithMapping("source",$model,$field))};
#end
        return result;
    }
#end

#end

#foreach($enum in $service.enums.values())
#if($enum.isForRequest())
    private ${enum.origClassSimpleName} mapEnum(${enum.shortName} source){
        String sourceValue = (source==null)?null:source.toString();
        for(${enum.origClassSimpleName} value:${enum.origClassSimpleName}.values()){
            if(value.toString().equals(sourceValue)){
                return value;
            }
        }
        return null;
    }
#end

#if($enum.isForResponse())
    private ${enum.getShortName()} mapEnum(${enum.origClassSimpleName} source){
        String sourceValue = (source==null)?null:source.toString();
        for(${enum.getShortName()} value:${enum.getShortName()}.values()){
            if(value.toString().equals(sourceValue)){
                return value;
            }
        }
        return null;
    }
#end
#end
}